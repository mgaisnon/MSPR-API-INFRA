name: CI Infra (Render Orchestrator)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  render:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # 1) Charger .env → exporte toutes les variables dans l'environnement
      - name: Load .env
        id: env
        shell: bash
        run: |
          set -euo pipefail
          if [[ ! -f .env.ci.sample ]]; then
            echo "❌ Fichier .env introuvable à la racine du dépôt."
            echo "Crée un .env avec les variables listées dans la doc de ce workflow."
            exit 1
          fi
          # Export de toutes les clés
          set -a
          source .env.ci.sample
          set +a

          # Normalise les images en lowercase (ex: GHCR)
          IMG_CLIENTS="$(echo "${IMG_CLIENTS:-}" | tr '[:upper:]' '[:lower:]')"
          IMG_PRODUITS="$(echo "${IMG_PRODUITS:-}" | tr '[:upper:]' '[:lower:]')"
          IMG_COMMANDES="$(echo "${IMG_COMMANDES:-}" | tr '[:upper:]' '[:lower:]')"

          # Timeout par défaut
          WAIT_TIMEOUT="${WAIT_TIMEOUT:-600}"

          # Expose dans GITHUB_OUTPUT pour réutilisation explicite
          {
            echo "IMG_CLIENTS=${IMG_CLIENTS}"
            echo "IMG_PRODUITS=${IMG_PRODUITS}"
            echo "IMG_COMMANDES=${IMG_COMMANDES}"
            echo "DB_CLIENTS=${DB_CLIENTS:-}"
            echo "DB_PRODUITS=${DB_PRODUITS:-}"
            echo "DB_COMMANDES=${DB_COMMANDES:-}"
            echo "RENDER_HOOK_CLIENTS=${RENDER_HOOK_CLIENTS:-}"
            echo "RENDER_HOOK_PRODUITS=${RENDER_HOOK_PRODUITS:-}"
            echo "RENDER_HOOK_COMMANDES=${RENDER_HOOK_COMMANDES:-}"
            echo "RENDER_URL_CLIENTS=${RENDER_URL_CLIENTS:-}"
            echo "RENDER_URL_PRODUITS=${RENDER_URL_PRODUITS:-}"
            echo "RENDER_URL_COMMANDES=${RENDER_URL_COMMANDES:-}"
            echo "WAIT_TIMEOUT=${WAIT_TIMEOUT}"
          } >> "$GITHUB_OUTPUT"

      # (Optionnel) login GHCR si tes images sont privées (sinon, retire ce bloc)
      # Pour l'utiliser, ajoute dans .env : GHCR_USERNAME=ton_user GHCR_TOKEN=ton_token
      - name: GHCR login (optional)
        if: ${{ steps.env.outputs.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ steps.env.outputs.GHCR_USERNAME }}
          password: ${{ steps.env.outputs.GHCR_TOKEN }}

      # 2) Petit helper pour attendre la DB
      - name: wait_for_db helper
        id: helper
        run: |
          cat > wait_for_db.py <<'PY'
          import os, sys, time
          from sqlalchemy import create_engine, text

          url = sys.argv[1]
          timeout = int(sys.argv[2])
          end = time.time() + timeout

          while time.time() < end:
              try:
                  eng = create_engine(url, pool_pre_ping=True)
                  with eng.connect() as c:
                      c.execute(text("SELECT 1"))
                  print("DB ready")
                  sys.exit(0)
              except Exception as e:
                  print("DB not ready:", e)
                  time.sleep(3)

          print("Timeout")
          sys.exit(1)
          PY

      # 3) INIT DB (idempotent) — exécuté SEULEMENT si DB_* est renseignée
      - name: Init DB - clients
        if: ${{ steps.env.outputs.DB_CLIENTS != '' }}
        env:
          DB_URL: ${{ steps.env.outputs.DB_CLIENTS }}
          IMG:    ${{ steps.env.outputs.IMG_CLIENTS }}
          WAIT:   ${{ steps.env.outputs.WAIT_TIMEOUT }}
        run: |
          set -euo pipefail
          python wait_for_db.py "$DB_URL" "$WAIT"
          docker pull "$IMG" || true
          docker run --rm -e DATABASE_URL="$DB_URL" "$IMG" python -m app.init_db

      - name: Init DB - produits
        if: ${{ steps.env.outputs.DB_PRODUITS != '' }}
        env:
          DB_URL: ${{ steps.env.outputs.DB_PRODUITS }}
          IMG:    ${{ steps.env.outputs.IMG_PRODUITS }}
          WAIT:   ${{ steps.env.outputs.WAIT_TIMEOUT }}
        run: |
          set -euo pipefail
          python wait_for_db.py "$DB_URL" "$WAIT"
          docker pull "$IMG" || true
          docker run --rm -e DATABASE_URL="$DB_URL" "$IMG" python -m app.init_db

      - name: Init DB - commandes
        if: ${{ steps.env.outputs.DB_COMMANDES != '' }}
        env:
          DB_URL: ${{ steps.env.outputs.DB_COMMANDES }}
          IMG:    ${{ steps.env.outputs.IMG_COMMANDES }}
          WAIT:   ${{ steps.env.outputs.WAIT_TIMEOUT }}
        run: |
          set -euo pipefail
          python wait_for_db.py "$DB_URL" "$WAIT"
          docker pull "$IMG" || true
          docker run --rm -e DATABASE_URL="$DB_URL" "$IMG" python -m app.init_db

      # 4) Déclenchements Render avec imgURL (URL-encodée)
      - name: Trigger Render - clients
        if: ${{ steps.env.outputs.RENDER_HOOK_CLIENTS != '' }}
        env:
          HOOK: ${{ steps.env.outputs.RENDER_HOOK_CLIENTS }}
          IMG:  ${{ steps.env.outputs.IMG_CLIENTS }}
        run: |
          python - <<'PY'
          import os, urllib.parse, urllib.request
          hook=os.environ["HOOK"]; img=os.environ["IMG"]
          url = f"{hook}?imgURL={urllib.parse.quote(img, safe='')}" 
          print("→ Clients:", img)
          print(urllib.request.urlopen(url).read())
          PY

      - name: Trigger Render - produits
        if: ${{ steps.env.outputs.RENDER_HOOK_PRODUITS != '' }}
        env:
          HOOK: ${{ steps.env.outputs.RENDER_HOOK_PRODUITS }}
          IMG:  ${{ steps.env.outputs.IMG_PRODUITS }}
        run: |
          python - <<'PY'
          import os, urllib.parse, urllib.request
          hook=os.environ["HOOK"]; img=os.environ["IMG"]
          url = f"{hook}?imgURL={urllib.parse.quote(img, safe='')}"
          print("→ Produits:", img)
          print(urllib.request.urlopen(url).read())
          PY

      - name: Trigger Render - commandes
        if: ${{ steps.env.outputs.RENDER_HOOK_COMMANDES != '' }}
        env:
          HOOK: ${{ steps.env.outputs.RENDER_HOOK_COMMANDES }}
          IMG:  ${{ steps.env.outputs.IMG_COMMANDES }}
        run: |
          python - <<'PY'
          import os, urllib.parse, urllib.request
          hook=os.environ["HOOK"]; img=os.environ["IMG"]
          url = f"{hook}?imgURL={urllib.parse.quote(img, safe='')}"
          print("→ Commandes:", img)
          print(urllib.request.urlopen(url).read())
          PY

      # 5) Readiness checks (si URLs publiques renseignées)
      - name: Wait readiness - clients
        if: ${{ steps.env.outputs.RENDER_URL_CLIENTS != '' }}
        env:
          URL:   ${{ steps.env.outputs.RENDER_URL_CLIENTS }}
          WAIT:  ${{ steps.env.outputs.WAIT_TIMEOUT }}
        run: |
          set -euo pipefail
          end=$((SECONDS + WAIT))
          while [ $SECONDS -lt $end ]; do
            curl -fsS "$URL/health" >/dev/null || curl -fsS "$URL/docs" >/dev/null || curl -fsS "$URL/" >/dev/null && exit 0
            sleep 5
          done
          echo "❌ timeout clients ($WAIT s)"; exit 1

      - name: Wait readiness - produits
        if: ${{ steps.env.outputs.RENDER_URL_PRODUITS != '' }}
        env:
          URL:   ${{ steps.env.outputs.RENDER_URL_PRODUITS }}
          WAIT:  ${{ steps.env.outputs.WAIT_TIMEOUT }}
        run: |
          set -euo pipefail
          end=$((SECONDS + WAIT))
          while [ $SECONDS -lt $end ]; do
            curl -fsS "$URL/health" >/dev/null || curl -fsS "$URL/docs" >/dev/null || curl -fsS "$URL/" >/dev/null && exit 0
            sleep 5
          done
          echo "❌ timeout produits ($WAIT s)"; exit 1

      - name: Wait readiness - commandes
        if: ${{ steps.env.outputs.RENDER_URL_COMMANDES != '' }}
        env:
          URL:   ${{ steps.env.outputs.RENDER_URL_COMMANDES }}
          WAIT:  ${{ steps.env.outputs.WAIT_TIMEOUT }}
        run: |
          set -euo pipefail
          end=$((SECONDS + WAIT))
          while [ $SECONDS -lt $end ]; do
            curl -fsS "$URL/health" >/dev/null || curl -fsS "$URL/docs" >/dev/null || curl -fsS "$URL/" >/dev/null && exit 0
            sleep 5
          done
          echo "❌ timeout commandes ($WAIT s)"; exit 1
