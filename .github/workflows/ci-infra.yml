name: CI Infra (Render deploy)

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["**"]
  workflow_dispatch:
    inputs:
      img_api_clients:
        description: "Image clients"
        required: true
        default: "ghcr.io/mgaisnon/mspr-api-clients:latest"
      img_api_produits:
        description: "Image produits"
        required: true
        default: "ghcr.io/mgaisnon/mspr-api-produits:latest"
      img_api_commandes:
        description: "Image commandes"
        required: true
        default: "ghcr.io/mgaisnon/mspr-api-commandes:latest"
      run_local_tests:
        description: "Lancer la stack en local pour des smoke tests ?"
        type: boolean
        default: false

permissions:
  contents: read

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      clients:   ${{ steps.imgs.outputs.clients }}
      produits:  ${{ steps.imgs.outputs.produits }}
      commandes: ${{ steps.imgs.outputs.commandes }}
    steps:
      - uses: actions/checkout@v4

      - name: Select images
        id: imgs
        shell: bash
        run: |
          C="${{ github.event.inputs.img_api_clients   || 'ghcr.io/mgaisnon/mspr-api-clients:latest' }}"
          P="${{ github.event.inputs.img_api_produits  || 'ghcr.io/mgaisnon/mspr-api-produits:latest' }}"
          O="${{ github.event.inputs.img_api_commandes || 'ghcr.io/mgaisnon/mspr-api-commandes:latest' }}"
          echo "clients=$C"   >> $GITHUB_OUTPUT
          echo "produits=$P"  >> $GITHUB_OUTPUT
          echo "commandes=$O" >> $GITHUB_OUTPUT
          echo "Selected:"
          echo "  clients   = $C"
          echo "  produits  = $P"
          echo "  commandes = $O"

  # Optionnel: tests Compose locaux (d√©sactiv√©s par d√©faut)
  compose-ci:
    runs-on: ubuntu-latest
    needs: [prepare]
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run_local_tests == 'true' }}
    steps:
      - uses: actions/checkout@v4

      - name: Login GHCR (si images priv√©es)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Generate CI compose (remove build, set images, force uvicorn)
        env:
          IMG_API_CLIENTS:  ${{ needs.prepare.outputs.clients }}
          IMG_API_PRODUITS: ${{ needs.prepare.outputs.produits }}
          IMG_API_COMMANDES: ${{ needs.prepare.outputs.commandes }}
        run: |
          set -euo pipefail
          yq e 'del(.services[].build)' docker-compose.yml > docker-compose.ci.yml

          yq e -i '
            .services["api-clients"].image   = strenv(IMG_API_CLIENTS)   |
            .services["api-produits"].image  = strenv(IMG_API_PRODUITS)  |
            .services["api-commandes"].image = strenv(IMG_API_COMMANDES)
          ' docker-compose.ci.yml

          # Neutralise un √©ventuel entrypoint MySQL et force uvicorn (adapte le module si besoin)
          yq e -i '
            .services["api-clients"].entrypoint   = [] |
            .services["api-produits"].entrypoint  = [] |
            .services["api-commandes"].entrypoint = []
          ' docker-compose.ci.yml

          yq e -i '
            .services["api-clients"].command   = ["uvicorn","app.main:app","--host","0.0.0.0","--port","8001"] |
            .services["api-commandes"].command = ["uvicorn","app.main:app","--host","0.0.0.0","--port","8002"] |
            .services["api-produits"].command  = ["uvicorn","app.main:app","--host","0.0.0.0","--port","8003"]
          ' docker-compose.ci.yml

          docker compose -f docker-compose.ci.yml config

      - name: Up stack
        run: |
          docker compose -f docker-compose.ci.yml up -d
          docker compose -f docker-compose.ci.yml ps

      - name: Smoke tests (retries)
        run: |
          set -euo pipefail
          wait_http() {
            local url="$1"; local name="$2"; local tries=40
            for i in $(seq 1 $tries); do
              if curl -fsS "$url" >/dev/null; then
                echo "‚úÖ $name OK ($url)"; return 0
              fi
              echo "‚Ä¶ waiting $name ($i/$tries)"; sleep 3
            done
            echo "‚ùå $name KO"; return 1
          }
          try_api() {
            local base="$1"; local svc="$2"
            wait_http "$base/health" "$svc" || \
            wait_http "$base/docs"   "$svc" || \
            wait_http "$base/"       "$svc" || \
            (docker compose -f docker-compose.ci.yml logs "$svc" && exit 1)
          }
          try_api http://localhost:8001 api-clients
          try_api http://localhost:8002 api-commandes
          try_api http://localhost:8003 api-produits
          wait_http http://localhost:15672 rabbitmq || true
          wait_http http://localhost:9090  prometheus || true
          wait_http http://localhost:3000  grafana || true

      - name: Logs on failure
        if: failure()
        run: docker compose -f docker-compose.ci.yml logs --no-color

      - name: Down
        if: always()
        run: docker compose -f docker-compose.ci.yml down -v
  
  render-deploy:
    name: üöÄ Deploy to Render (hooks) + wait
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    env:
      WAIT_TIMEOUT: ${{ inputs.wait_timeout_seconds || '600' }}
      HOOK_CLIENTS:   ${{ secrets.RENDER_HOOK_CLIENTS }}
      HOOK_PRODUITS:  ${{ secrets.RENDER_HOOK_PRODUITS }}
      HOOK_COMMANDES: ${{ secrets.RENDER_HOOK_COMMANDES }}
      URL_CLIENTS:    ${{ secrets.RENDER_URL_CLIENTS }}
      URL_PRODUITS:   ${{ secrets.RENDER_URL_PRODUITS }}
      URL_COMMANDES:  ${{ secrets.RENDER_URL_COMMANDES }}

    steps:
      - name: Check deploy hooks presence
        id: have
        shell: bash
        run: |
          set -euo pipefail
          ok=true
          for v in HOOK_CLIENTS HOOK_PRODUITS HOOK_COMMANDES; do
            if [ -z "${!v:-}" ]; then
              echo "‚ùå Missing secret: $v"
              ok=false
            fi
          done
          if $ok; then
            echo "OK=true"  >> "$GITHUB_OUTPUT"
          else
            echo "OK=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Skip (no deploy hooks)
        if: ${{ steps.have.outputs.OK != 'true' }}
        run: echo "Skipping Render deploy (add secrets: RENDER_HOOK_CLIENTS, RENDER_HOOK_COMMANDES, RENDER_HOOK_PRODUITS)."

      - name: Trigger Render deploy - clients
        if: ${{ steps.have.outputs.OK == 'true' }}
        run: |
          set -euo pipefail
          curl -fsSL -X POST "${HOOK_CLIENTS}"
          echo "‚Üí Deploy trigger sent (clients)."

      - name: Trigger Render deploy - produits
        if: ${{ steps.have.outputs.OK == 'true' }}
        run: |
          set -euo pipefail
          curl -fsSL -X POST "${HOOK_PRODUITS}"
          echo "‚Üí Deploy trigger sent (produits)."

      - name: Trigger Render deploy - commandes
        if: ${{ steps.have.outputs.OK == 'true' }}
        run: |
          set -euo pipefail
          curl -fsSL -X POST "${HOOK_COMMANDES}"
          echo "‚Üí Deploy trigger sent (commandes)."

      - name: Wait readiness (clients)
        if: ${{ steps.have.outputs.OK == 'true' && env.URL_CLIENTS != '' }}
        run: |
          set -euo pipefail
          end=$((SECONDS + ${WAIT_TIMEOUT}))
          url="${URL_CLIENTS}"
          while [ $SECONDS -lt $end ]; do
            if curl -fsS "$url/health" >/dev/null || curl -fsS "$url/docs" >/dev/null || curl -fsS "$url/" >/dev/null; then
              echo "‚úÖ clients ready: $url"; exit 0
            fi
            sleep 5
          done
          echo "‚ùå timeout clients (${WAIT_TIMEOUT}s)"; exit 1

      - name: Wait readiness (produits)
        if: ${{ steps.have.outputs.OK == 'true' && env.URL_PRODUITS != '' }}
        run: |
          set -euo pipefail
          end=$((SECONDS + ${WAIT_TIMEOUT}))
          url="${URL_PRODUITS}"
          while [ $SECONDS -lt $end ]; do
            if curl -fsS "$url/health" >/dev/null || curl -fsS "$url/docs" >/dev/null || curl -fsS "$url/" >/dev/null; then
              echo "‚úÖ produits ready: $url"; exit 0
            fi
            sleep 5
          done
          echo "‚ùå timeout produits (${WAIT_TIMEOUT}s)"; exit 1

      - name: Wait readiness (commandes)
        if: ${{ steps.have.outputs.OK == 'true' && env.URL_COMMANDES != '' }}
        run: |
          set -euo pipefail
          end=$((SECONDS + ${WAIT_TIMEOUT}))
          url="${URL_COMMANDES}"
          while [ $SECONDS -lt $end ]; do
            if curl -fsS "$url/health" >/dev/null || curl -fsS "$url/docs" >/dev/null || curl -fsS "$url/" >/dev/null; then
              echo "‚úÖ commandes ready: $url"; exit 0
            fi
            sleep 5
          done
          echo "‚ùå timeout commandes (${WAIT_TIMEOUT}s)"; exit 1

      - name: Info (no URLs provided)
        if: ${{ steps.have.outputs.OK == 'true' && env.URL_CLIENTS == '' && env.URL_PRODUITS == '' && env.URL_COMMANDES == '' }}
        run: echo "Hooks OK but no public URLs set ‚Äî readiness checks skipped."
