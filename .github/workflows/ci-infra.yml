name: CI Infra (Render deploy)

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["**"]
  workflow_dispatch:
    inputs:
      img_api_clients:
        description: "Image clients"
        required: true
        default: "ghcr.io/mgaisnon/mspr-api-clients:latest"
      img_api_produits:
        description: "Image produits"
        required: true
        default: "ghcr.io/mgaisnon/mspr-api-produits:latest"
      img_api_commandes:
        description: "Image commandes"
        required: true
        default: "ghcr.io/mgaisnon/mspr-api-commandes:latest"
      run_local_tests:
        description: "Lancer la stack en local pour des smoke tests ?"
        type: boolean
        default: false

permissions:
  contents: read

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      clients:   ${{ steps.imgs.outputs.clients }}
      produits:  ${{ steps.imgs.outputs.produits }}
      commandes: ${{ steps.imgs.outputs.commandes }}
    steps:
      - uses: actions/checkout@v4

      - name: Select images
        id: imgs
        shell: bash
        run: |
          C="${{ github.event.inputs.img_api_clients   || 'ghcr.io/mgaisnon/mspr-api-clients:latest' }}"
          P="${{ github.event.inputs.img_api_produits  || 'ghcr.io/mgaisnon/mspr-api-produits:latest' }}"
          O="${{ github.event.inputs.img_api_commandes || 'ghcr.io/mgaisnon/mspr-api-commandes:latest' }}"
          echo "clients=$C"   >> $GITHUB_OUTPUT
          echo "produits=$P"  >> $GITHUB_OUTPUT
          echo "commandes=$O" >> $GITHUB_OUTPUT
          echo "Selected:"
          echo "  clients   = $C"
          echo "  produits  = $P"
          echo "  commandes = $O"

  # Optionnel: tests Compose locaux (d√©sactiv√©s par d√©faut)
  compose-ci:
    runs-on: ubuntu-latest
    needs: [prepare]
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run_local_tests == 'true' }}
    steps:
      - uses: actions/checkout@v4

      - name: Login GHCR (si images priv√©es)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Generate CI compose (remove build, set images, force uvicorn)
        env:
          IMG_API_CLIENTS:  ${{ needs.prepare.outputs.clients }}
          IMG_API_PRODUITS: ${{ needs.prepare.outputs.produits }}
          IMG_API_COMMANDES: ${{ needs.prepare.outputs.commandes }}
        run: |
          set -euo pipefail
          yq e 'del(.services[].build)' docker-compose.yml > docker-compose.ci.yml

          yq e -i '
            .services["api-clients"].image   = strenv(IMG_API_CLIENTS)   |
            .services["api-produits"].image  = strenv(IMG_API_PRODUITS)  |
            .services["api-commandes"].image = strenv(IMG_API_COMMANDES)
          ' docker-compose.ci.yml

          # Neutralise un √©ventuel entrypoint MySQL et force uvicorn (adapte le module si besoin)
          yq e -i '
            .services["api-clients"].entrypoint   = [] |
            .services["api-produits"].entrypoint  = [] |
            .services["api-commandes"].entrypoint = []
          ' docker-compose.ci.yml

          yq e -i '
            .services["api-clients"].command   = ["uvicorn","app.main:app","--host","0.0.0.0","--port","8001"] |
            .services["api-commandes"].command = ["uvicorn","app.main:app","--host","0.0.0.0","--port","8002"] |
            .services["api-produits"].command  = ["uvicorn","app.main:app","--host","0.0.0.0","--port","8003"]
          ' docker-compose.ci.yml

          docker compose -f docker-compose.ci.yml config

      - name: Up stack
        run: |
          docker compose -f docker-compose.ci.yml up -d
          docker compose -f docker-compose.ci.yml ps

      - name: Smoke tests (retries)
        run: |
          set -euo pipefail
          wait_http() {
            local url="$1"; local name="$2"; local tries=40
            for i in $(seq 1 $tries); do
              if curl -fsS "$url" >/dev/null; then
                echo "‚úÖ $name OK ($url)"; return 0
              fi
              echo "‚Ä¶ waiting $name ($i/$tries)"; sleep 3
            done
            echo "‚ùå $name KO"; return 1
          }
          try_api() {
            local base="$1"; local svc="$2"
            wait_http "$base/health" "$svc" || \
            wait_http "$base/docs"   "$svc" || \
            wait_http "$base/"       "$svc" || \
            (docker compose -f docker-compose.ci.yml logs "$svc" && exit 1)
          }
          try_api http://localhost:8001 api-clients
          try_api http://localhost:8002 api-commandes
          try_api http://localhost:8003 api-produits
          wait_http http://localhost:15672 rabbitmq || true
          wait_http http://localhost:9090  prometheus || true
          wait_http http://localhost:3000  grafana || true

      - name: Logs on failure
        if: failure()
        run: docker compose -f docker-compose.ci.yml logs --no-color

      - name: Down
        if: always()
        run: docker compose -f docker-compose.ci.yml down -v

  # üöÄ D√©ploiement Render via Deploy Hooks
  deploy-render:
    runs-on: ubuntu-latest
    needs: [prepare]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Check deploy hooks presence
        id: have
        shell: bash
        run: |
          ok=1
          [ -n "${{ secrets.RENDER_HOOK_CLIENTS }}" ]   || { echo "‚ÑπÔ∏è Missing RENDER_HOOK_CLIENTS"; ok=0; }
          [ -n "${{ secrets.RENDER_HOOK_COMMANDES }}" ] || { echo "‚ÑπÔ∏è Missing RENDER_HOOK_COMMANDES"; ok=0; }
          [ -n "${{ secrets.RENDER_HOOK_PRODUITS }}" ]  || { echo "‚ÑπÔ∏è Missing RENDER_HOOK_PRODUITS"; ok=0; }
          if [ $ok -eq 1 ]; then echo "OK=true" >> $GITHUB_OUTPUT; else echo "OK=false" >> $GITHUB_OUTPUT; fi

      - name: Skip (no deploy hooks)
        if: steps.have.outputs.OK != 'true'
        run: echo "Skipping Render deploy (add secrets: RENDER_HOOK_CLIENTS, RENDER_HOOK_COMMANDES, RENDER_HOOK_PRODUITS)."

      # Facultatif : ping les images pour les r√©chauffer c√¥t√© registry
      - name: Pre-pull images (optional)
        if: steps.have.outputs.OK == 'true'
        run: |
          docker pull "${{ needs.prepare.outputs.clients }}"   || true
          docker pull "${{ needs.prepare.outputs.produits }}"  || true
          docker pull "${{ needs.prepare.outputs.commandes }}" || true

      # D√©clenche le redeploy Render (chaque hook correspond √† un service Render)
      - name: Trigger Render deploy - clients
        if: steps.have.outputs.OK == 'true'
        run: |
          curl -fsSL -X POST "${{ secrets.RENDER_HOOK_CLIENTS }}" \
            -H 'Content-Type: application/json' \
            -d "{\"image\":\"${{ needs.prepare.outputs.clients }}\",\"actor\":\"${{ github.actor }}\",\"sha\":\"${{ github.sha }}\",\"repo\":\"${{ github.repository }}\"}"
          echo "Triggered clients"

      - name: Trigger Render deploy - commandes
        if: steps.have.outputs.OK == 'true'
        run: |
          curl -fsSL -X POST "${{ secrets.RENDER_HOOK_COMMANDES }}" \
            -H 'Content-Type: application/json' \
            -d "{\"image\":\"${{ needs.prepare.outputs.commandes }}\",\"actor\":\"${{ github.actor }}\",\"sha\":\"${{ github.sha }}\",\"repo\":\"${{ github.repository }}\"}"
          echo "Triggered commandes"

      - name: Trigger Render deploy - produits
        if: steps.have.outputs.OK == 'true'
        run: |
          curl -fsSL -X POST "${{ secrets.RENDER_HOOK_PRODUITS }}" \
            -H 'Content-Type: application/json' \
            -d "{\"image\":\"${{ needs.prepare.outputs.produits }}\",\"actor\":\"${{ github.actor }}\",\"sha\":\"${{ github.sha }}\",\"repo\":\"${{ github.repository }}\"}"
          echo "Triggered produits"
